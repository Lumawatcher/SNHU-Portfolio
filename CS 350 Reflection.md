CS 350 - Emerging Systems Architecture and Technology

For this class, I selected two projects to showcase. The first is a state machine driver that blinks one of two morse code messages on the TI development board's LEDs. The board blink SOS, until either of the side buttons is pressed at which point it will blink OK. The board will finish whatever message it is currently blinking before switching messages to avoid confusion. The second project was our final project, which was a simple mockup for a thermostat. The board runs on a 100 ms timer, with tasks assigned for every 200 ms, 500 ms and every second. If either button is pushed, an interrupt runs that sets that button's flag, which signals to the board that the target temperature for the thermostat should be incremented or decremented, depending on the button. Every 200 ms these flags are checked and the target temperature is updated. Every 500 ms, the board checks the current temperature via it's on board thermometer and determines whether the heat needs to be on or off. This is indicated by whether red LED is on or off. Every second, the board outputs basic information to the terminal and reset the counter. 

For both of these projects, I'm proud of my solutions overall. For the morse code project, I think there are probably a lot of ways to accomplish the task, so I spent a lot of time trying to find the simplest solution that would take the least memory and processing power. While I think there is probably some room for improvment in verbosity, I think that the logic of my solution is solid, and I'm very happy with it. For the final, I'm proud of the simplicity of my solution. The logic is air tight, and the board accomplishes what it needs to without too many bells and whistles. 

I learned a lot in this class about how hardware functions on a more basic level. I've always been really interested in embedded systems architecture, so getting a closer look and some hands on practice with the development board was a great experience. I also got a look at some of Texas Instrument's (TI) drivers, which helped give me a better idea of what it takes to program a board like the SimpleLink CC3220S we used for this course. I also got some experience using TI's eclipse-based IDE, Code Composer Studio. While I had a lot of problems getting it running properly on my machine, it gave me some valuable practice in developing in a testing environment. 

When it came to maintaining these projects, I tried to use the most up-to-date drivers and example projects from TI, in hopes that it would easily maintained and adapted to other projects. As for readability, I tried to follow my general outline for programming. I use variable names that are simple and descriptive, avoiding abbreviations where possible. I try to make my code logic self-explanatory and legible by effectively leveraging whitespace and function names, and I leave comments where I think my code may be a bit harder to follow.
