CS 320 23EW3
Software Test Automation and QA
2/26/2023

 For this course, we created a few classes and class controllers for a future mobile application. The purpose of designing these classes was to create an environment where we could practice writing unit tests for our own classes. We wrote these tests using Junit. Over the span of the course, my methodology for writing my classes and for writing my Junit tests changed pretty significantly. When I first started, I listed out the requirements outlined for each class, and proceeded to write the code that would ensure that the requirements were met. I then wrote unit tests that tested for each requirement, separated by the categories of potential errors. For a quick example, I wrote tests that would ensure that inputs for the string variables that were over the limit would be rejected, and inputs within the limit would be accepted. 

By the end of the course, I was trying to use a more test driven development methodology for developing my classes. While I was writing the final class for this course, I tried writing my unit tests first, basing those off the requirements outlined in the assignment rubric. I then proceeded to write the classes using my normal process of outlining the requirements and tackling them one-by-one, except when I thought a requirement was met, I ran the test to ensure the test I designed for that requirement would pass now that the code for that requirement was written. This saved me a lot of time troubleshooting my classes, as when I wrote something that didnâ€™t work, I knew immediately after it was written. 

A big pro of using test driven development, at least for me, was being able to get quick feedback on my code without having to compile it into a functioning program. The biggest weakness, however, in this methodology was my lack of experience and knowledge in testing principles. I missed some pretty obvious tests, like testing that my exception handling caught null entries, or checking that the border of each character limit was accepted as expected. However, I think the projects for this course really gave me a lot of useful tools for developing efficient and functional code. 
